\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kd}{public} \PYG{k+kd}{static} \PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{Integer}\PYG{o}{\PYGZgt{}} \PYG{n+nf}{bfs}\PYG{p}{(}\PYG{n}{Graph} \PYG{n}{G}\PYG{p}{,} \PYG{k+kt}{int} \PYG{n}{startingNode}\PYG{p}{)} \PYG{p}{\PYGZob{}}
	\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{Integer}\PYG{o}{\PYGZgt{}} \PYG{n}{path} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ArrayList}\PYG{o}{\PYGZlt{}}\PYG{n}{Integer}\PYG{o}{\PYGZgt{}}\PYG{p}{();}
	\PYG{n}{List}\PYG{o}{\PYGZlt{}}\PYG{n}{Integer}\PYG{o}{\PYGZgt{}} \PYG{n}{toVisitNodes} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ArrayList}\PYG{o}{\PYGZlt{}}\PYG{n}{Integer}\PYG{o}{\PYGZgt{}}\PYG{p}{();}
	\PYG{k}{for} \PYG{p}{(}\PYG{n}{Integer} \PYG{n}{key} \PYG{p}{:} \PYG{n}{G}\PYG{p}{.}\PYG{n+na}{getMap}\PYG{p}{().}\PYG{n+na}{keySet}\PYG{p}{())} \PYG{p}{\PYGZob{}}
		\PYG{n}{mapMPD}\PYG{p}{.}\PYG{n+na}{put}\PYG{p}{(}\PYG{n}{key}\PYG{p}{,} \PYG{k}{new} \PYG{n}{MPD}\PYG{p}{(}\PYG{k+kc}{false}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{));}
	\PYG{p}{\PYGZcb{}}
	\PYG{n}{toVisitNodes}\PYG{p}{.}\PYG{n+na}{add}\PYG{p}{(}\PYG{n}{startingNode}\PYG{p}{);}
	\PYG{n}{mapMPD}\PYG{p}{.}\PYG{n+na}{put}\PYG{p}{(}\PYG{n}{startingNode}\PYG{p}{,} \PYG{k}{new} \PYG{n}{MPD}\PYG{p}{(}\PYG{k+kc}{false}\PYG{p}{,} \PYG{o}{\PYGZhy{}}\PYG{l+m+mi}{1}\PYG{p}{,} \PYG{l+m+mf}{0.0}\PYG{p}{));}
	
	\PYG{k}{if} \PYG{p}{(}\PYG{n}{G}\PYG{p}{.}\PYG{n+na}{isWeighted}\PYG{p}{())} \PYG{p}{\PYGZob{}}
		
		\PYG{n}{System}\PYG{p}{.}\PYG{n+na}{out}\PYG{p}{.}\PYG{n+na}{println}\PYG{p}{(}\PYG{l+s}{\PYGZdq{}Please consider using Dijkstra Algorithm on weighted graph if you would like to find shortest paths.\PYGZdq{}}\PYG{p}{);}
		
	\PYG{p}{\PYGZcb{}}
		
		\PYG{k}{while} \PYG{p}{(}\PYG{o}{!}\PYG{n}{toVisitNodes}\PYG{p}{.}\PYG{n+na}{isEmpty}\PYG{p}{())} \PYG{p}{\PYGZob{}}

			\PYG{k+kt}{int} \PYG{n}{currentNode} \PYG{o}{=} \PYG{n}{toVisitNodes}\PYG{p}{.}\PYG{n+na}{remove}\PYG{p}{(}\PYG{l+m+mi}{0}\PYG{p}{);}
			\PYG{n}{mapMPD}\PYG{p}{.}\PYG{n+na}{get}\PYG{p}{(}\PYG{n}{currentNode}\PYG{p}{).}\PYG{n+na}{marked} \PYG{o}{=} \PYG{k+kc}{true}\PYG{p}{;}
			\PYG{n}{path}\PYG{p}{.}\PYG{n+na}{add}\PYG{p}{(}\PYG{n}{currentNode}\PYG{p}{);}
			
			\PYG{k}{for} \PYG{p}{(}\PYG{n}{DirectedEdge} \PYG{n}{edge} \PYG{p}{:} \PYG{n}{G}\PYG{p}{.}\PYG{n+na}{getMap}\PYG{p}{().}\PYG{n+na}{get}\PYG{p}{(}\PYG{n}{currentNode}\PYG{p}{))} \PYG{p}{\PYGZob{}}
				\PYG{k}{if} \PYG{p}{(}\PYG{o}{!}\PYG{n}{toVisitNodes}\PYG{p}{.}\PYG{n+na}{contains}\PYG{p}{(}\PYG{n}{edge}\PYG{p}{.}\PYG{n+na}{to}\PYG{p}{())} \PYG{o}{\PYGZam{}\PYGZam{}} \PYG{o}{!}\PYG{n}{mapMPD}\PYG{p}{.}\PYG{n+na}{get}\PYG{p}{(}\PYG{n}{edge}\PYG{p}{.}\PYG{n+na}{to}\PYG{p}{()).}\PYG{n+na}{marked}\PYG{p}{)} \PYG{p}{\PYGZob{}}
					\PYG{n}{toVisitNodes}\PYG{p}{.}\PYG{n+na}{add}\PYG{p}{(}\PYG{n}{edge}\PYG{p}{.}\PYG{n+na}{to}\PYG{p}{());}
					\PYG{n}{mapMPD}\PYG{p}{.}\PYG{n+na}{get}\PYG{p}{(}\PYG{n}{edge}\PYG{p}{.}\PYG{n+na}{to}\PYG{p}{()).}\PYG{n+na}{previous} \PYG{o}{=} \PYG{n}{currentNode}\PYG{p}{;}
					\PYG{n}{mapMPD}\PYG{p}{.}\PYG{n+na}{get}\PYG{p}{(}\PYG{n}{edge}\PYG{p}{.}\PYG{n+na}{to}\PYG{p}{()).}\PYG{n+na}{distance} \PYG{o}{=} \PYG{n}{mapMPD}\PYG{p}{.}\PYG{n+na}{get}\PYG{p}{(}\PYG{n}{currentNode}\PYG{p}{).}\PYG{n+na}{distance}\PYG{o}{+}\PYG{l+m+mi}{1}\PYG{p}{;}					
				\PYG{p}{\PYGZcb{}}
			\PYG{p}{\PYGZcb{}}
		\PYG{p}{\PYGZcb{}}
	\PYG{c+c1}{//\PYGZcb{}}
	\PYG{k}{return} \PYG{n}{path}\PYG{p}{;}
\PYG{p}{\PYGZcb{}}	
\end{Verbatim}

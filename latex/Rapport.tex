\documentclass{article}
% To include code color syntaxing
\usepackage{minted}
% To include images
\usepackage{graphicx}
% To define margins
\usepackage[a4paper,left=2.5cm,right=2.5cm,top=2.5cm,bottom=2.5cm]{geometry}
% To comment multiple lines
\usepackage{comment}
% To use hyperlink
\usepackage{hyperref}
% Setting all hyperlinks color to black, then setting only url colors to blue
\hypersetup{
  colorlinks,
  allcolors=.,
  urlcolor=blue,
}

\begin{document}

\begin{titlepage}
	\begin{center}
		\huge{\bfseries II.2315 â€“ Project : Advanced algorithm and programming} \\
		\rule{16cm}{0.4pt} \\
		\huge{\bfseries Australia - Canberra} \\
		\vspace{3mm}
		\includegraphics[scale=0.20]{assets/CanberraMap}
		\rule{16cm}{0.4pt} \\
		\vspace{5mm}
		\includegraphics[scale=0.20]{assets/logoISEP} \\
		\textsc{\large Sarah HEOUAINE - David LAMY-VERDIN - Elia TSO}
		\medbreak
		\textsc{\large 2020 - 2021}
	\end{center}
\end{titlepage}

\renewcommand{\contentsname}{Table of contents}
\tableofcontents
\cleardoublepage

\section{Introduction}

\subsection{City of choice}

	We selected the city of Canberra, capital of Australia, for our project. This city has a total of 2433 stations and 2759 links.
	
\subsection{Goals of the project}

	This project had for first goal to create a graph representing the transport map of Canberra out of mere data. After this graph has been created, we could use it to reach other goals described in the below list:
	
\begin{itemize}
\item[-] Search algorithms \\
Implementation of the Bread-First Search Algorithm \\
Implementation of the Dijkstra Algorithm
\medbreak
\item[-] Applications of those algorithms \\
Searching for shortest paths \\
Splitting the map into clusters
\end{itemize}

	Through this project, optimization also had to be done as searching for shortest paths and splitting into clusters a graph as large as Canberra Transport Map was particularly demanding on resources and took a considerable amount of time.
	
\subsection{Collection of data : GTFS files}
	
	To build our graph, we used data retrieved from \href{https://www.transport.act.gov.au/contact-us/information-for-developers}{Australia Government official website}. This data come as multiple \textit{.txt} files. After studying them, it has been figured out that only \textit{stops.txt} and \textit{stop\_times.txt} were actually useful.
	
\begin{figure}[h]
\begin{center}
	\includegraphics[scale=1]{assets/data}
\end{center} 
\caption{Data included in each \textit{.txt} file and relations between them}
\end{figure} 


	Using only those, we could create the stations which are represented in our graph as nodes and we could also link each of them and thus creating our edges.
	
\newpage
	
	The \textit{stops.txt} file provide us with \textit{stop\_id},  \textit{stop\_lat}, \textit{stop\_lon} which are all the information we needed to create our nodes while the \textit{stop\_times.txt} give us \textit{trip\_id} which allow us to create our edges. A trip informs about which stations are linked together and in which order as it defines a bus or subway line such as the R3 line of Canberra for example:
	
\begin{figure}[h]
\begin{center}
	\includegraphics[scale=1]{assets/R3}
\end{center}
\caption{R3 subway line of Canberra}
\end{figure} 

\section{Creation of the graph}

\subsection{Graph}

\mintinline{java}{Graph.java} is the class used for building graphs.
The class contains the three following attributes:

\begin{itemize}
\item[-]\mint[breaklines, breaksymbolleft=]{java}{private Map<Integer, List<DirectedEdge>> map = new TreeMap<Integer,List<DirectedEdge>>()} This \mintinline{java}{Map} is used to store the adjacency lists of every node of our graphs. Each \mintinline{java}{Key} of the \mintinline{java}{Map} designates a node of our graph and the corresponding \mintinline{java}{Value} of the \mintinline{java}{Map} is its adjacency list. The choice to use a \mintinline{java}{Map} over a \mintinline{java}{List} is because unlike graphs where nodes labels are consecutive numbers, the stations of Canberra are not labeled consecutively. Therefore, using a \mintinline{java}{Map} makes it easier to look for an adjacency list of a specific station. This would not have been possible with a \mintinline{java}{List}. 
\item[-]\mintinline{java}{private boolean weighted} indicates if the graph is weighted or not.
\item[-]\mintinline{java}{private boolean directed} indicates if the graph is directed or not.
\end{itemize}

	Besides these attributes, \mintinline{java}{Graph.java} also has several methods whose most important ones are the following:

\begin{itemize}
\item[-]\mint[breaklines, breaksymbolleft=]{java}{private void convertTxt(File stopsFile, File stopTimesFile, boolean weighted, boolean directed)}
\item[-]\mint{java}{private void addNodesFromTxt(File stopsFile)}
\item[-]\mint{java}{private void addEdgesFromTxt(File stopTimesFile)}
\item[-]\mint{java}{private void addWeightsFromTxt(File stopsFile)}
\end{itemize}

\begingroup
\setlength{\rightskip}{0pt plus 1 fil}
The first method is used to initialize a graph by calling the other three methods and in the meantime setting the attributes \mintinline[breaklines, breakafter=_]{java}{private boolean weighted} and \mintinline{java}{private boolean directed}.
\endgroup

The other three methods are used to parse \textit{stops.txt} and \textit{stop\_times.txt}, retrieve the data and create the nodes and edges of our graph.

\subsection{Nodes}

For \textit{stops.txt}, each line was containing these informations in this order: stop\_id, stop\_name, stop\_lat, stop\_lon. In order to create our nodes, we had to use the stop\_id as labels for our nodes. To do so 

For \textit{stop\_times.txt}, the informations are the following ones: trip\_id, arrival\_time, departure\_time, stop\_id, stop\_sequence, timepoint.




\begin{comment}
\begin{minted}[breaklines]{java}
public static void dijkstra(Graph G, int startingNode) {
	List<Integer> toVisitNodes = new ArrayList<Integer>();
	toVisitNodes.add(startingNode);
	previous.put(startingNode, startingNode);
	distance.put(startingNode, 0.0);
		
	if (verifyNonNegative(G)) {
		for (Integer key : G.getMap().keySet()) {
			if (key != startingNode) {
				marked.put(key, false);
				distance.put(key, Double.POSITIVE_INFINITY); //999999999 is supposed to be infinity
			}	
		}
			
		boolean end = false;
		
		while (!end) {
			end = false;
			double minimalDistance = Double.POSITIVE_INFINITY;
			int currentNode = startingNode;
			// With the for loop below, we choose our node with the minimal distance as our next node
			for (int i = 0 ; i < toVisitNodes.size() ; i ++) {
				if (distance.get(toVisitNodes.get(i)) < minimalDistance) {
					minimalDistance = distance.get(toVisitNodes.get(i));
					currentNode = toVisitNodes.get(i);
				}
				// We select our next node and remove it from toVisitNodes
				toVisitNodes.remove((Integer)currentNode);
			}
			// We set our node as marked after it is selected and removed from toVisitNodes
			marked.put(currentNode, true);
				
			for (DirectedEdge edge : G.getMap().get(currentNode)) {
					// We update the distance of the neighbors nodes
					// We check the distance, if they are shorter, we change it, if not, we do not
				if (distance.get(edge.to()) > distance.get(edge.from()) + edge.weight()) {
					distance.put(edge.to(), distance.get(edge.from()) + edge.weight());
					previous.put(edge.to(), edge.from());						
						
					}
					// We take care not to select again a marked node
				if (!marked.get(edge.to())) {
					toVisitNodes.add(edge.to());
				}
			}
			
				// If there is not any node left to visit, we stop the loop
			if (toVisitNodes.isEmpty()) end = true;
		}
	} else {
		System.out.println("Dijkstra algorithm cannot be used as there is a negative weight in the graph!");
	}
}
\end{minted}
\end{comment}
\end{document}
